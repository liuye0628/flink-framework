package com.atguigu.javase.c_oop;

/**
 * 基本介绍:一个类的内部又完整的嵌套了另一个类结构,被嵌套的类称为内部类,是类的第五大成员,内部类最大的特点就是可以直接访问私有属性,并且可以体现类与类之间的包含关系
 */
public class $14_InnerClass {
    //1.静态内部类(定义在外部类的成员位置,有static修饰)
    static class one{
        /**
         * ①可以访问外部类的所有静态成员,包含私有的,但不能直接访问非静态成员
         * ②可以添加任意访问修饰符(public/private/默认/protected,因为它的地位就是一个成员)
         * ③作用域:同其他的成员为整个类体
         * ④调用方式:外部类类名.静态内部类类名 对象名 = new 外部类类名.静态内部类类名()
         */
    }
    //2.成员内部类(定义在外部类的成员位置,没有static修饰)
    class two{
        /*
         *①可以访问外部类的所有成员包括私有的和非静态的
         *②可以添加任意访问修饰符(public/private/默认/protected,因为它的地位就是一个成员)
         *③作用域:同其他的成员为整个类体
         *④调用方式:外部类.内部类 对象名 = new 外部类().new 内部类()
         */
    }

    public static void main(String[] args) {
        //3.匿名内部类(定义在外部类的局部位置,比如方法中,并且没有类名)------>重点!!!!!!!
        /*
        * ①可以直接访问外部类的所有成员,包含私有的
        * ②不能添加访问修饰符,因为它的地位就是一个局部变量
        * ③作用域仅仅在定义在它的方法和代码块中
        * ④如果外部类和内部类的成员重名,匿名内部类访问的话默认遵循就近原则,如果想访问外部类的成员,则可使用(外部类名.this.成员)去访问
        * ⑤使用场景:当做实参传递,简单高效
        *
        *
        * */
        C c = new C() {
            @Override
            public void test(){
                System.out.println("匿名内部类的test");
            }
        };
        c.test();
        //4.局部内部类(定义在外部类的局部位置,比如方法中,并且有类名)
        /**
         * ①可以直接访问外部类的所有成员,包含私有的
         * ②不能添加访问修饰符,因为它的地位就是一个局部变量,局部变量是不能使用修饰符的,但是可以使用final修饰,因为局部变量可以使用final
         * ③作用域仅仅在定义它的方法或代码块中
         * ④外部类访问局部内部类的成员(创建对象再访问,必须在作用域内)
         */
        class D{
            public void print(){
                System.out.println("/////");
            }
        }

    }
}


class C{
    public int id;
    public String name;
    public void test(){
        System.out.println("--------");
    }
}
