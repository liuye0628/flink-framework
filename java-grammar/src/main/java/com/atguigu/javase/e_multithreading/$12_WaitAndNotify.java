package com.atguigu.javase.e_multithreading;

/**
 * 等待唤醒机制
 * 1.为什么要进行线程间通信:
 * 多个线程在处理同一个资源,但是处理的动作(线程的任务确不相同),而多个线程并发执行时,在默认的情况下CPU是随机切换线程的,当我们需要多个线程来完成
 * 一件任务,并且我们希望他们有规律的执行,那么多线程之间需要一些通信机制,可以协调他们的工作,以此来帮我们达到多线程共同操作一份数据
 * 比如:线程A是用来生成包子的,线程B是用来吃包子的,包子可以理解为同一资源,线程A和线程B处理的动作,一个是生产,一个是消费,此时B线程必须等到
 * A线程完成后才能执行,那么线程A与线程B之间就需要线程通信即等待唤醒机制
 * 2.什么是等待唤醒机制:
 * 这是多个线程之前的一种协作机制,谈到线程我们经常想到的是线程间的竞争(race),比如去争夺锁,但这并不是故事的全部,线程间也有协作机制,就是在一个
 * 线程满足某个条件时,就进入等待状态(wait()/wait(time)),等待其他线程执行完他们的指定代码后再将其唤醒(notify());或可以指定wait的时间,等时间
 * 到了自动唤醒;在有多个线程进行等待时,如果需要,可以使用notifyAll()来唤醒所有的等待线程,wait/notify就是线程间的一种协作机制
 *      ①wait:线程不再活动,不再参与调度,进入wait set中,因此不会浪费CPU资源,也不会去竞争锁了,这时的线程状态即是WAITING或TIMED_WAITING,它
 *      还要别的线程执行一个特别的动作,也即是通知(notify),或者等待时间到,在这个对象上等待的线程从wait set中释放出来,重新进入到调度队列(ready queue)中
 *      ②notify:即选取所通知对象的wait set中的一个线程释放
 *      ③notifyAll:即释放所通知对象的wait set上的全部线程
 *      注意:被通知线程被唤醒后也不一定能立即恢复执行,因为它当初中断的地方是在同步块内,而此刻它不持有锁,所以他需要再次尝试去获取锁(很可能面临其他线程的竞争)
 *      成功后才能在当初调用wait方法之后的地方恢复执行
 *      总结如下:
 *      ·如果能获取锁,线程就从WAITING状态变成RUNNABLE(可运行状态)
 *      ·否则,线程就从WAITING状态又变成BLOCKED(等待锁)状态
 */

public class $12_WaitAndNotify {

    /**
     * 调用wait和notify方法需要注意的细节
     *  ①wait方法和notify方法必须要由同一个锁对象调用,因为:对应的锁对象可以通过notify唤醒使用同一个锁对象的wait方法方法之后的线程
     *  ②wait方法与notify方法是属于object类的方法的,因为锁对象可以是任意对象,而任意对象的所属类都是继承了object类的
     *  ③wait方法和notify方法必须要在同步代码块或在同步函数中使用,因为:必须通过锁对象调用这两个方法
     */

    /**
     * 等待唤醒机制可以解决经典的"生产者与消费者问题"
     * 生产者与消费者问题(英语:Producter-consumer problem),也称有限缓冲问题(英语:Bounded-buffer problem),是一个多线程同步问题的经典案例,
     * 该问题描述了两个(多个)共享固定大小缓冲区的线程--即所谓的"生产者"和"消费者"--在实际的运行中会发生的问题,生产者的主要作用是生成一定量的数据
     * 放到缓冲区中,然后重复此过程,与此同时,消费者也在缓冲区消耗这些数据,该问题的关键就是要保证生产者不会在缓冲区满时加入数据,消费者也不会在缓冲区中空时消耗数据
     * 生产者与消费者问题中其实隐含了两个问题:
     * ①线程安全问题:因为生产者与消费者共享数据缓冲区,不过这个问题可以使用同步解决
     * ②线程的协调工作问题:
     *      要解决该问题,就必须让生产者线程在缓冲区满时等待(wait),暂停进入阻塞状态,等到下次消费者消耗了缓冲区中的数据的时候,通知(notify)正在等待的线程恢复到就绪状态,
     *      重新开始向缓冲区中添加数据,同样,也可以在消费者线程在缓冲区空时等待(wait),暂停进入阻塞状态,等待生产者往缓冲区添加数据之后,再通知(notify)正在等待的线程恢复
     *      到就绪状态,通过这样的通信机制来解决此类问题
     */
}
